<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Factory TUI (Web + Config)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0c10;color:#c5c8c6}
  body{display:flex;align-items:center;justify-content:center}
  #screen{
    font: 16px/20px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    white-space: pre; background:#0b0c10; padding:22px 26px;
    border:1px solid #2b2f36; border-radius:10px; box-shadow:0 10px 36px rgba(0,0,0,.45);
    min-width: 120ch; max-width: 170ch;
  }
</style>
<pre id="screen"></pre>
<script src="./factory-sim.js"></script>
<script>
    let sim = null;
    let wasmModule = null;
    const screen = document.getElementById('screen');

    const DEFAULT_STATIONS = [
        {m:3,mean:3, stdev:0.2},
        {m:2,mean:2, stdev:0.3},
        {m:1,mean:1.5, stdev:0.3},
        {m:3,mean:1, stdev:0.6},
        {m:3,mean:3, stdev:0.3}
    ];
    
    let stations = structuredClone(DEFAULT_STATIONS);

    async function initializeSimulation() {
        screen.textContent = 'Loading factory simulation...';
        try {
            // Check if Module is available
            if (typeof Module === 'undefined') {
                throw new Error('Module is not defined. The WebAssembly module failed to load.');
            }
            
            console.log('Module type:', typeof Module);
            wasmModule = await Module();
            console.log('WASM module initialized:', wasmModule);
            sim = new wasmModule.Sim();
            const config = { stations: DEFAULT_STATIONS };
            sim.loadFromConfig(JSON.stringify(config));
            sim.initialize();
            
            // Start the animation loop after successful initialization
            requestAnimationFrame(tick);
        }
        catch (error) {
            console.error('Failed to initialize simulation:', error);
            screen.textContent = `
┌─────────────────────────────────────────────────────────────┐
│                  SIMULATION LOAD FAILED                     │
├─────────────────────────────────────────────────────────────┤
│ Could not initialize the WebAssembly simulation module.     │
│                                                             │
│ Possible causes:                                            │
│ • WebAssembly not supported by browser                      │
│ • Corrupted factory-sim.wasm file                           │
│ • Configuration format error                                │
│                                                             │
│ TO RECOVER:                                                 │
│ • Refresh the page (F5 or Ctrl+R)                           │
│ • Check browser console for details                         │
│ • Try a different browser                                   │
└─────────────────────────────────────────────────────────────┘`;
        }
    }

    // Initialize when page loads - add small delay to ensure script is fully loaded
    window.addEventListener('load', () => {
        setTimeout(initializeSimulation, 100);
    });


    // UI state
    const M = {Idle:'I', Busy:'B'};
    let t=0, speed=1, paused=false;
    let showConfig=false, sel=0; // selected station index
    let errorState = false;
    
    function readStateFromWASM(){
        if (!sim) return { t: 0, wipTotal: 0, thRolling: 0, stations: [] };
        
        let wsVec = null;
        try {
            // Debug logging around critical time
            if (t >= 8.0 && t <= 8.2) {
                console.log(`Debug: About to stepUntil(${t.toFixed(3)})`);
            }
            
            sim.stepUntil(t);
            
            const metrics = sim.getMetricsView();
            wsVec = sim.getWorkspaceView();
            
            const n = wsVec.size();
            const stations = [];
            for (let i = 0; i < n; i++) {
                const w = wsVec.get(i);
                const machines = Array.from({length: w.m}, (_, k) => (
                      k < w.busy ? 'B' : 'I'
                    ));
                stations.push({
                    name: `S${w.id+1}`,
                    qlen: w.queue,
                    machines
                });
            }
           
           return {
                t: metrics.t,
                wipTotal: metrics.wip,
                thRolling: metrics.avgTh,
                stations
           };
        } catch (error) {
            console.error('WASM error at t=' + t.toFixed(1) + 's:', error);
            errorState = true;
            showErrorScreen('SIMULATION CRASHED', 
                'The WebAssembly module encountered a memory error.\nThis requires a full page refresh to recover.');
            return { t: 0, wipTotal: 0, thRolling: 0, stations: [] };
        } finally {
            // Always clean up WASM memory, even on error
            if (wsVec) wsVec.delete();
        }
    }

  function showErrorScreen(title, message) {
    screen.textContent = `
┌─────────────────────────────────────────────────────────────┐
│ ${title.padEnd(59)} │
├─────────────────────────────────────────────────────────────┤
│ ${message.split('\n')[0].padEnd(59)} │
│ ${(message.split('\n')[1] || '').padEnd(59)} │
│                                                             │
│ TO RESTART:                                                 │
│ • Press F5 or Ctrl+R to refresh the page                   │
│ • Or reload the page manually                              │
└─────────────────────────────────────────────────────────────┘`;
  }

  function render(st){
    // If we're in error state, show error message
    if (errorState) {
      return; // Error message already set in screen.textContent
    }
    
    const lines = [];
    const header = ` Factory Simulator       t=${st.t.toFixed(1)}s  WIP=${padN(st.wipTotal,2)}  TH=${st.thRolling.toFixed(1)} jobs/min  speed=${speed.toFixed(1)}x`;
    lines.push(header);
    lines.push('='.repeat(Math.max(120, header.length)));

    lines.push('' + '─'.repeat(100) + '> SHIP');
    lines.push('');

    st.stations.forEach((s, idx) => {
      const bar = '[' + '#'.repeat(Math.min(s.qlen, 40)).padEnd(40,' ') + ']';
      lines.push(`${pad(s.name, 6)}  Q:${bar}  (${s.qlen}) ${idx<st.stations.length-1?'→→':''}`);
      const machineStatuses = s.machines.join(' ');
      lines.push(`  Machines: ${machineStatuses}`);
      lines.push('.'.repeat(72));
    });

    lines.push(` Legend: [I] idle  [B] busy Q=[#####................]  `);
    lines.push(` Controls: [space] pause=${paused?'ON ':'OFF'}  [-/=] slower/faster  [c] config  [R] restart`);

    if (showConfig) {
      renderWithConfig(lines);}
    else {
      screen.textContent = lines.join('\n');
    }
  }

  function renderWithConfig(L) {

    // --- Config sidebar ---
    const W = 58; // sidebar width
    const RIGHT = [];
    RIGHT.push(' CONFIG '.padEnd(W,'='));
    RIGHT.push(' ↑/↓ : select station');
    RIGHT.push(' m/M : -/+ machines');
    RIGHT.push(' p/P : -/+ queue cap');
    RIGHT.push(' x   : set CCR to selected');
    RIGHT.push(' s   : save to localStorage');
    RIGHT.push(' r   : reset to defaults');
    RIGHT.push(' c   : close panel');
    RIGHT.push('-'.repeat(W));

    stations.forEach((s,i)=>{
      const mark = (i===sel)?'▶':' ';
      RIGHT.push(`${mark} S${i+1}      machines:${padN(s.m,2)}  mean:${padN(s.mean.toFixed(1),4)}  stdev:${s.stdev.toFixed(1)}`);
    });
    RIGHT.push('-'.repeat(W));
    RIGHT.push(`Tip: Use config to adjust station parameters.`);

    // merge columns with a divider
    const merged = mergeColumns(L, RIGHT, ' │ ');
    screen.textContent = merged.join('\n');
  }

  // Missing setCCR function
  function setCCR(stationIndex) {
    // This function would set the CCR (Critical Control Resource) but needs implementation
    console.log('Setting CCR to station:', stationIndex);
  }
  // ====== Input ======
  addEventListener('keydown', e=>{
    if(e.key===' ') paused=!paused;
    if(e.key==='=') speed = Math.min(8, speed*1.5);
    if(e.key==='-') speed = Math.max(0.1, speed/1.5);
    if(e.key==='c') showConfig = !showConfig;
    if(e.key==='R') { initializeNewSimulation(); return; }
    if(!showConfig) return;

    if(e.key==='ArrowUp')   sel = (sel-1+stations.length)%stations.length;
    if(e.key==='ArrowDown') sel = (sel+1)%stations.length;

    // machines (only allow changes when paused or early in simulation)
    if(e.key==='m'){ 
      stations[sel].m = Math.max(1, stations[sel].m-1); 
      if (t < 1.0 || paused) updateSimConfig(); 
      else flash('Pause simulation or restart to change configuration');
    }
    if(e.key==='M'){ 
      stations[sel].m = Math.min(24, stations[sel].m+1); 
      if (t < 1.0 || paused) updateSimConfig(); 
      else flash('Pause simulation or restart to change configuration');
    }

    // mean processing time (only allow changes when paused or early in simulation)
    if(e.key==='p'){ 
      stations[sel].mean = Math.max(0.1, stations[sel].mean-0.1); 
      if (t < 1.0 || paused) updateSimConfig(); 
      else flash('Pause simulation or restart to change configuration');
    }
    if(e.key==='P'){ 
      stations[sel].mean = Math.min(10, stations[sel].mean+0.1); 
      if (t < 1.0 || paused) updateSimConfig(); 
      else flash('Pause simulation or restart to change configuration');
    }

    // set CCR
    if(e.key==='x'){ setCCR(sel); }

    // save/reset
    if(e.key==='s'){ saveConfig(stations); flash('Saved config to localStorage'); }
    if(e.key==='r'){ stations = structuredClone(DEFAULT_STATIONS); initializeNewSimulation(); setCCR(3); flash('Reset to defaults'); }
  });
  
  function updateSimConfig() {
    if (sim) {
      // Reinitialize the entire simulation to avoid memory access issues
      // with old events referencing invalid machine/workspace IDs
      initializeNewSimulation();
    }
  }
  
  async function initializeNewSimulation() {
    try {
      // Clear reference to old sim (let garbage collector handle it)
      sim = null;
      
      // Reset error state for manual restarts
      errorState = false;
      
      // Longer delay to ensure WebAssembly cleanup before creating new instance
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Create a completely fresh simulation instance
      sim = new wasmModule.Sim();
      const config = { stations: stations };
      console.log(config);
      sim.loadFromConfig(JSON.stringify(config));
      sim.initialize();  // This clears all state and resets everything
      
      // Reset time and state
      t = 0;
      paused = false;
      last = performance.now();
      
      flash('Simulation restarted');
      console.log('Simulation restarted at t=0, jobs cleared, machines reset');
    }
    catch (error) {
      console.error('Failed to restart simulation:', error);
      errorState = true;
      showErrorScreen('RESTART FAILED', 
          'Cannot restart simulation - WebAssembly module error.\nA full page refresh is required.');
    }
  }

  // loop
  let last = performance.now();
  
  function tick(now){
    // Skip ticking if we're in an error state
    if (errorState) {
      requestAnimationFrame(tick);
      return;
    }
    
    const dt = Math.min(0.2, (now - last)/1000);
    last = now;
    
    if (!paused) {
      t += dt * speed;
    }
    
    const state = readStateFromWASM();
    render(state);
    requestAnimationFrame(tick);
  }

  // ====== Helpers ======
  function meter(val, cap, width){
    const p = cap ? val/cap : 0;
    const fill = Math.round(p*width);
    return '[' + '#'.repeat(fill).padEnd(width, ' ') + ']';
  }
  function penetrationTicks(val, cap){
    if (!cap) return '[            ]';
    const width = 12;
    const p = Math.min(1, Math.max(0, val/cap));
    const pos = Math.round(p*width);
    const t1 = Math.round(width*0.33), t2 = Math.round(width*0.66), t3 = Math.round(width*0.90);
    let s = '';
    for (let i=0;i<=width;i++){
      if (i===t1 || i===t2 || i===t3) s += '|';
      else if (i===pos) s += '▲';
      else s += '.';
    }
    return '['+s+']';
  }
  function chunk(arr, n){ const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out; }
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const pad=(s,n)=> (s+' '.repeat(n)).slice(0,n);
  const padN=(x,n)=> String(x).padStart(n,' ');

  function mergeColumns(leftLines, rightLines, sep=' │ '){
    const lh = leftLines.length, rh = rightLines.length;
    const Lw = leftLines.reduce((m,l)=>Math.max(m,l.length),0);
    const H = Math.max(lh, rh);
    const out = [];
    for (let i=0;i<H;i++){
      const L = (i<lh ? leftLines[i] : '').padEnd(Lw,' ');
      const R = (i<rh ? rightLines[i] : '');
      out.push(L + sep + R);
    }
    return out;
  }

  // tiny toast (console only, keeps file simple)
  function flash(msg){ console.log('[config]', msg); }

  // persistence
  function saveConfig(cfg){ localStorage.setItem('factory_tui_cfg', JSON.stringify(cfg)); }
  function loadConfig(){ try{ return JSON.parse(localStorage.getItem('factory_tui_cfg')||'null'); } catch { return null; } }
</script>
</html>